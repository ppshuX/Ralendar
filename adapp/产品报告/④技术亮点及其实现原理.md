# â‘£ æŠ€æœ¯äº®ç‚¹åŠå…¶å®ç°åŸç†

## 4.1 Repository æ¨¡å¼ - ç»Ÿä¸€æ•°æ®è®¿é—®

### æŠ€æœ¯äº®ç‚¹
å®ç°äº†æœ¬åœ°/äº‘ç«¯æ•°æ®çš„ç»Ÿä¸€è®¿é—®æ¥å£ï¼Œç”¨æˆ·æ— éœ€å…³å¿ƒæ•°æ®æ¥æºï¼Œä¸šåŠ¡é€»è¾‘å±‚ä¸æ•°æ®å±‚è§£è€¦ã€‚

### å®ç°åŸç†

#### æ ¸å¿ƒä»£ç 
```kotlin
class EventRepository(
    private val eventDao: EventDao,
    private val api: CalendarApi,
    private val context: Context
) {
    suspend fun getAllEvents(): Result<List<Event>> {
        return if (PreferenceManager.isCloudMode(context)) {
            // äº‘ç«¯æ¨¡å¼ï¼šä»APIè·å–
            try {
                val cloudEvents = api.getAllEvents()
                Result.success(cloudEvents.map { EventConverter.toLocalEvent(it) })
            } catch (e: Exception) {
                Result.failure(e)
            }
        } else {
            // æœ¬åœ°æ¨¡å¼ï¼šä»æ•°æ®åº“è·å–
            try {
                Result.success(eventDao.getUserEvents())
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }
    
    suspend fun addEvent(event: Event): Result<Event> {
        return if (PreferenceManager.isCloudMode(context) && PreferenceManager.isLoggedIn(context)) {
            // äº‘ç«¯æ¨¡å¼ï¼šå…ˆä¿å­˜åˆ°äº‘ç«¯ï¼Œå†åŒæ­¥åˆ°æœ¬åœ°
            try {
                val cloudEvent = api.createEvent(EventConverter.toCloudEvent(event))
                val savedEvent = EventConverter.toLocalEvent(cloudEvent)
                eventDao.insert(savedEvent)
                Result.success(savedEvent)
            } catch (e: Exception) {
                Result.failure(e)
            }
        } else {
            // æœ¬åœ°æ¨¡å¼ï¼šç›´æ¥ä¿å­˜åˆ°æ•°æ®åº“
            try {
                val savedEvent = eventDao.insert(event)
                Result.success(savedEvent)
            } catch (e: Exception) {
                Result.failure(e)
            }
        }
    }
}
```

#### è®¾è®¡ä¼˜åŠ¿
1. **ç»Ÿä¸€æ¥å£**ï¼šä¸šåŠ¡é€»è¾‘å±‚åªéœ€è°ƒç”¨ `EventRepository` çš„æ–¹æ³•ï¼Œæ— éœ€å…³å¿ƒæ•°æ®æ¥æº
2. **çµæ´»åˆ‡æ¢**ï¼šæ ¹æ®é…ç½®è‡ªåŠ¨åˆ‡æ¢æœ¬åœ°/äº‘ç«¯æ¨¡å¼
3. **é”™è¯¯å¤„ç†**ï¼šç»Ÿä¸€çš„é”™è¯¯å¤„ç†æœºåˆ¶ï¼Œä½¿ç”¨ `Result` å°è£…æˆåŠŸ/å¤±è´¥çŠ¶æ€
4. **æ•°æ®è½¬æ¢**ï¼šè‡ªåŠ¨å¤„ç†æœ¬åœ°Eventå’Œäº‘ç«¯CloudEventä¹‹é—´çš„è½¬æ¢

#### ä½¿ç”¨ç¤ºä¾‹
```kotlin
// ä¸šåŠ¡é€»è¾‘å±‚ä½¿ç”¨Repository
lifecycleScope.launch {
    val result = eventRepository.getAllEvents()
    result.fold(
        onSuccess = { events ->
            // å¤„ç†æˆåŠŸæƒ…å†µ
            adapter.updateEvents(events)
        },
        onFailure = { error ->
            // å¤„ç†å¤±è´¥æƒ…å†µ
            Toast.makeText(this@MainActivity, "åŠ è½½å¤±è´¥: ${error.message}", Toast.LENGTH_SHORT).show()
        }
    )
}
```

**æ–‡ä»¶ä½ç½®**ï¼š`adapp/app/src/main/java/com/ncu/kotlincalendar/data/repository/EventRepository.kt`

---

## 4.2 Facade æ¨¡å¼ - ç»Ÿä¸€APIæ¥å£

### æŠ€æœ¯äº®ç‚¹
ä½¿ç”¨ Facade æ¨¡å¼èšåˆæ‰€æœ‰APIæœåŠ¡ï¼Œæä¾›ç»Ÿä¸€çš„è®¿é—®å…¥å£ï¼Œç®€åŒ–APIè°ƒç”¨ã€‚

### å®ç°åŸç†

#### æ ¸å¿ƒä»£ç 
```kotlin
// ç»Ÿä¸€APIæ¥å£ï¼ˆFacadeæ¨¡å¼ï¼‰
interface CalendarApi : CalendarService, HolidayService, AIService, WeatherService {
    // è¿™ä¸ªæ¥å£ç»§æ‰¿äº†æ‰€æœ‰æœåŠ¡æ¥å£
    // æä¾›äº†ä¸€ä¸ªç»Ÿä¸€çš„APIè®¿é—®ç‚¹
}

// RetrofitClient - å•ä¾‹å®¢æˆ·ç«¯
object RetrofitClient {
    private const val BASE_URL = "https://app7626.acapp.acwing.com.cn/api/"
    
    val api: CalendarApi by lazy {
        Retrofit.Builder()
            .baseUrl(BASE_URL)
            .client(okHttpClient)
            .addConverterFactory(GsonConverterFactory.create())
            .build()
            .create(CalendarApi::class.java)
    }
}

// ä½¿ç”¨æ–¹å¼
val api = RetrofitClient.api
val lunar = api.getLunarDate("2025-11-12")
val holiday = api.checkHoliday("2025-11-12")
val aiResult = api.parseEventFromText(request)
```

#### è®¾è®¡ä¼˜åŠ¿
1. **å•ä¸€å…¥å£**ï¼šæ‰€æœ‰APIè°ƒç”¨éƒ½é€šè¿‡ `RetrofitClient.api`
2. **æ˜“äºæ‰©å±•**ï¼šæ·»åŠ æ–°æœåŠ¡åªéœ€ç»§æ‰¿æ–°æ¥å£
3. **ç±»å‹å®‰å…¨**ï¼šæ‰€æœ‰APIæ–¹æ³•éƒ½æœ‰ç±»å‹æ£€æŸ¥
4. **ç»Ÿä¸€é…ç½®**ï¼šBase URLã€è¶…æ—¶ç­‰é…ç½®ç»Ÿä¸€ç®¡ç†

#### æœåŠ¡æ¥å£æ‹†åˆ†
```kotlin
// EventService - æ—¥ç¨‹ç›¸å…³API
interface EventService {
    @GET("events/")
    suspend fun getAllEvents(): List<CloudEvent>
    
    @POST("events/")
    suspend fun createEvent(@Body event: CloudEvent): CloudEvent
}

// HolidayService - èŠ‚æ—¥ç›¸å…³API
interface HolidayService {
    @GET("holidays/check/")
    suspend fun checkHoliday(@Query("date") date: String): HolidayResponse
    
    @GET("festivals/detail/")
    suspend fun getFestivalDetail(@Query("name") name: String?, @Query("date") date: String?): FestivalDetailResponse
}

// AIService - AIåŠ©æ‰‹ç›¸å…³API
interface AIService {
    @POST("ai/parse-event/")
    suspend fun parseEventFromText(@Body request: ParseEventRequest): ParseEventResponse
}
```

**æ–‡ä»¶ä½ç½®**ï¼š
- `adapp/app/src/main/java/com/ncu/kotlincalendar/api/CalendarApi.kt`
- `adapp/app/src/main/java/com/ncu/kotlincalendar/api/client/RetrofitClient.kt`

---

## 4.3 Manager æ¨¡å¼ - ä¸šåŠ¡é€»è¾‘å°è£…

### æŠ€æœ¯äº®ç‚¹
å°†ç›¸å…³ä¸šåŠ¡é€»è¾‘å°è£…åˆ°Managerç±»ä¸­ï¼Œæé«˜ä»£ç å¤ç”¨æ€§å’Œå¯ç»´æŠ¤æ€§ã€‚

### å®ç°åŸç†

#### ReminderManager - æé†’ç®¡ç†
```kotlin
class ReminderManager(private val context: Context) {
    private val alarmManager = context.getSystemService(Context.ALARM_SERVICE) as AlarmManager
    
    fun setReminder(event: Event) {
        if (event.reminderMinutes <= 0) return
        
        // è®¡ç®—æé†’æ—¶é—´
        val reminderTime = event.dateTime - (event.reminderMinutes * 60 * 1000)
        val currentTime = System.currentTimeMillis()
        
        if (reminderTime < currentTime) return
        
        // åˆ›å»ºPendingIntent
        val intent = Intent(context, AlarmReceiver::class.java).apply {
            putExtra("eventId", event.id)
            putExtra("eventTitle", event.title)
            putExtra("eventTime", event.dateTime)
        }
        val pendingIntent = PendingIntent.getBroadcast(
            context,
            event.id.toInt(),
            intent,
            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
        
        // è®¾ç½®ç²¾ç¡®æé†’ï¼ˆAndroid 6.0+ï¼‰
        if (Build.VERSION.SDK_INT >= Build.VERSION_CODES.M) {
            alarmManager.setExactAndAllowWhileIdle(
                AlarmManager.RTC_WAKEUP,
                reminderTime,
                pendingIntent
            )
        } else {
            alarmManager.setExact(AlarmManager.RTC_WAKEUP, reminderTime, pendingIntent)
        }
    }
    
    fun cancelReminder(event: Event) {
        val intent = Intent(context, AlarmReceiver::class.java)
        val pendingIntent = PendingIntent.getBroadcast(
            context,
            event.id.toInt(),
            intent,
            PendingIntent.FLAG_CANCEL_CURRENT or PendingIntent.FLAG_IMMUTABLE
        )
        alarmManager.cancel(pendingIntent)
    }
}
```

#### HolidayManager - èŠ‚æ—¥ä¿¡æ¯ç®¡ç†
```kotlin
class HolidayManager(
    private val festivalCardsContainer: LinearLayout,
    private val tvHolidayHint: TextView,
    private val context: Context,
    private val subscriptionManager: SubscriptionManager
) {
    private val festivalSubscriptionManager = FestivalSubscriptionManager(context)
    
    fun loadHolidayInfo(date: Long, lifecycleScope: LifecycleCoroutineScope) {
        lifecycleScope.launch(Dispatchers.IO) {
            try {
                val dateFormat = SimpleDateFormat("yyyy-MM-dd", Locale.getDefault())
                val dateStr = dateFormat.format(Date(date))
                
                // è°ƒç”¨APIè·å–èŠ‚æ—¥ä¿¡æ¯
                val response = RetrofitClient.api.checkHoliday(dateStr)
                
                // è·å–è®¢é˜…çš„èŠ‚æ—¥äº‹ä»¶
                val subscribedEvents = subscriptionManager.getVisibleEvents(null)
                    .filter { event ->
                        val eventDate = Instant.ofEpochMilli(event.dateTime)
                            .atZone(ZoneId.systemDefault())
                            .toLocalDate()
                        eventDate == selectedDate && event.subscriptionId != null
                    }
                
                withContext(Dispatchers.Main) {
                    // æ¸…ç©ºä¹‹å‰çš„å¡ç‰‡
                    festivalCardsContainer.removeAllViews()
                    
                    // æ˜¾ç¤ºå†œå†ä¿¡æ¯
                    addFestivalCard("ğŸ® å†œå†", response.lunar ?: "åŠ è½½ä¸­...", ...)
                    
                    // å¤„ç†APIè¿”å›çš„èŠ‚æ—¥åˆ—è¡¨
                    response.festivals?.forEach { festival ->
                        if (festivalSubscriptionManager.isSubscribed(festival.name)) {
                            addFestivalCard("${festival.emoji} ${festival.name}", "ç‚¹å‡»æŸ¥çœ‹è¯¦æƒ…", ...)
                        }
                    }
                }
            } catch (e: Exception) {
                // é”™è¯¯å¤„ç†
            }
        }
    }
}
```

#### è®¾è®¡ä¼˜åŠ¿
1. **èŒè´£å•ä¸€**ï¼šæ¯ä¸ªManagerè´Ÿè´£ç‰¹å®šåŠŸèƒ½
2. **æ˜“äºæµ‹è¯•**ï¼šä¸šåŠ¡é€»è¾‘ä¸UIåˆ†ç¦»
3. **ä»£ç å¤ç”¨**ï¼šå¤šä¸ªActivityå¯ä»¥å…±äº«Manager
4. **æ˜“äºç»´æŠ¤**ï¼šåŠŸèƒ½ä¿®æ”¹åªéœ€ä¿®æ”¹å¯¹åº”çš„Manager

**æ–‡ä»¶ä½ç½®**ï¼š
- `adapp/app/src/main/java/com/ncu/kotlincalendar/data/managers/ReminderManager.kt`
- `adapp/app/src/main/java/com/ncu/kotlincalendar/ui/managers/HolidayManager.kt`

---

## 4.4 åç¨‹å¼‚æ­¥å¤„ç† - æµç•…çš„ç”¨æˆ·ä½“éªŒ

### æŠ€æœ¯äº®ç‚¹
ä½¿ç”¨ Kotlin Coroutines å¤„ç†å¼‚æ­¥æ“ä½œï¼Œé¿å…é˜»å¡UIçº¿ç¨‹ï¼Œæä¾›æµç•…çš„ç”¨æˆ·ä½“éªŒã€‚

### å®ç°åŸç†

#### æ ¸å¿ƒä»£ç 
```kotlin
// ä½¿ç”¨åç¨‹å¤„ç†å¼‚æ­¥æ“ä½œ
lifecycleScope.launch(Dispatchers.IO) {
    try {
        // åœ¨IOçº¿ç¨‹æ‰§è¡Œè€—æ—¶æ“ä½œ
        val events = eventDao.getUserEvents()
        val holidays = RetrofitClient.api.checkHoliday("2025-11-12")
        
        withContext(Dispatchers.Main) {
            // åˆ‡æ¢åˆ°ä¸»çº¿ç¨‹æ›´æ–°UI
            adapter.updateEvents(events)
            updateHolidayDisplay(holidays)
        }
    } catch (e: Exception) {
        // é”™è¯¯å¤„ç†
        withContext(Dispatchers.Main) {
            Toast.makeText(this@MainActivity, "åŠ è½½å¤±è´¥: ${e.message}", Toast.LENGTH_SHORT).show()
        }
    }
}
```

#### Dispatcherä½¿ç”¨
- **Dispatchers.Main**ï¼šä¸»çº¿ç¨‹ï¼Œç”¨äºæ›´æ–°UI
- **Dispatchers.IO**ï¼šIOçº¿ç¨‹ï¼Œç”¨äºæ•°æ®åº“æ“ä½œã€ç½‘ç»œè¯·æ±‚ç­‰
- **Dispatchers.Default**ï¼šé»˜è®¤çº¿ç¨‹ï¼Œç”¨äºCPUå¯†é›†å‹ä»»åŠ¡

#### åç¨‹å–æ¶ˆ
```kotlin
// ä½¿ç”¨Jobç®¡ç†åç¨‹ç”Ÿå‘½å‘¨æœŸ
private var loadEventsJob: Job? = null

private fun loadAllEvents() {
    // å–æ¶ˆä¹‹å‰çš„åŠ è½½æ“ä½œï¼ˆé¿å…ç«æ€æ¡ä»¶ï¼‰
    loadEventsJob?.cancel()
    loadEventsJob = lifecycleScope.launch(Dispatchers.IO) {
        loadAllEventsSync()
    }
}
```

#### è®¾è®¡ä¼˜åŠ¿
1. **éé˜»å¡**ï¼šä¸ä¼šé˜»å¡UIçº¿ç¨‹
2. **ç®€æ´**ï¼šä»£ç æ¯”å›è°ƒæ›´æ¸…æ™°
3. **é”™è¯¯å¤„ç†**ï¼šç»Ÿä¸€çš„å¼‚å¸¸å¤„ç†æœºåˆ¶
4. **ç”Ÿå‘½å‘¨æœŸæ„ŸçŸ¥**ï¼šä½¿ç”¨ `lifecycleScope` è‡ªåŠ¨ç®¡ç†åç¨‹ç”Ÿå‘½å‘¨æœŸ

**æ–‡ä»¶ä½ç½®**ï¼š`adapp/app/src/main/java/com/ncu/kotlincalendar/MainActivity.kt`

---

## 4.5 å“åº”å¼UIæ›´æ–° - å®æ—¶æ•°æ®åŒæ­¥

### æŠ€æœ¯äº®ç‚¹
æ•°æ®ä¿®æ”¹åç«‹å³æ›´æ–°UIï¼Œæ— éœ€æ‰‹åŠ¨åˆ·æ–°ï¼Œæä¾›å³æ—¶åé¦ˆã€‚

### å®ç°åŸç†

#### æ ¸å¿ƒä»£ç 
```kotlin
// æ·»åŠ æ—¥ç¨‹åç«‹å³æ›´æ–°UI
private fun addEvent(...) {
    lifecycleScope.launch(Dispatchers.IO) {
        try {
            // 1. ä¿å­˜åˆ°æ•°æ®åº“
            val savedEvent = eventDao.insert(event)
            
            // 2. ç«‹å³æ·»åŠ åˆ°å†…å­˜åˆ—è¡¨
            withContext(Dispatchers.Main) {
                eventsList.add(savedEvent)
                datesWithEvents.add(eventDate)
                
                // 3. ç«‹å³åˆ·æ–°UI
                updateEventsList()
                updateCalendarDots()
                
                // 4. åˆ·æ–°æ—¥å†è§†å›¾
                calendarView.notifyCalendarChanged()
                weekCalendarView.notifyCalendarChanged()
            }
            
            // 5. å¼‚æ­¥åŒæ­¥åˆ°äº‘ç«¯ï¼ˆä¸é˜»å¡UIï¼‰
            if (isCloudMode) {
                eventRepository.syncToCloud(savedEvent)
            }
            
            // 6. è®¾ç½®æé†’
            reminderManager.setReminder(savedEvent)
        } catch (e: Exception) {
            // é”™è¯¯å¤„ç†
        }
    }
}

// ç¼–è¾‘æ—¥ç¨‹åç«‹å³æ›´æ–°UI
private fun updateEvent(...) {
    lifecycleScope.launch(Dispatchers.IO) {
        try {
            // 1. æ›´æ–°æ•°æ®åº“
            eventDao.update(event)
            
            // 2. ç«‹å³æ›´æ–°å†…å­˜åˆ—è¡¨
            withContext(Dispatchers.Main) {
                val index = eventsList.indexOfFirst { it.id == event.id }
                if (index >= 0) {
                    eventsList[index] = event
                }
                
                // 3. ç«‹å³åˆ·æ–°UI
                updateEventsList()
                updateCalendarDots()
            }
            
            // 4. å¼‚æ­¥åŒæ­¥åˆ°äº‘ç«¯
            if (isCloudMode) {
                eventRepository.syncToCloud(event)
            }
            
            // 5. æ›´æ–°æé†’
            reminderManager.cancelReminder(event)
            reminderManager.setReminder(event)
        } catch (e: Exception) {
            // é”™è¯¯å¤„ç†
        }
    }
}
```

#### è®¾è®¡ä¼˜åŠ¿
1. **å³æ—¶åé¦ˆ**ï¼šç”¨æˆ·æ“ä½œç«‹å³çœ‹åˆ°æ•ˆæœ
2. **æµç•…ä½“éªŒ**ï¼šæ— éœ€ç­‰å¾…ç½‘ç»œè¯·æ±‚å®Œæˆ
3. **æ•°æ®ä¸€è‡´æ€§**ï¼šæœ¬åœ°å’Œäº‘ç«¯æ•°æ®æœ€ç»ˆä¸€è‡´
4. **åŸå­æ›´æ–°**ï¼šä½¿ç”¨ `withContext` ç¡®ä¿UIæ›´æ–°çš„åŸå­æ€§

**æ–‡ä»¶ä½ç½®**ï¼š`adapp/app/src/main/java/com/ncu/kotlincalendar/MainActivity.kt`

---

## 4.6 æ™ºèƒ½æ—¥æœŸè§£æ - AIè‡ªç„¶è¯­è¨€å¤„ç†

### æŠ€æœ¯äº®ç‚¹
æ”¯æŒè‡ªç„¶è¯­è¨€è¾“å…¥ï¼ŒAIè‡ªåŠ¨è§£ææ—¥æœŸã€æ—¶é—´ã€åœ°ç‚¹ç­‰ä¿¡æ¯ï¼Œæå‡ç”¨æˆ·ä½“éªŒã€‚

### å®ç°åŸç†

#### æ ¸å¿ƒä»£ç 
```kotlin
// AIè§£æè‡ªç„¶è¯­è¨€
private fun showAIEventDialog() {
    val dialog = AlertDialog.Builder(this).create()
    val dialogView = layoutInflater.inflate(R.layout.dialog_ai_event, null)
    val editText = dialogView.findViewById<EditText>(R.id.editText)
    val btnConfirm = dialogView.findViewById<Button>(R.id.btnConfirm)
    
    btnConfirm.setOnClickListener {
        val userInput = editText.text.toString().trim() // "æ˜å¤©ä¸‹åˆ3ç‚¹å¼€ä¼š"
        if (userInput.isEmpty()) {
            Toast.makeText(this, "è¯·è¾“å…¥æ—¥ç¨‹æè¿°", Toast.LENGTH_SHORT).show()
            return@setOnClickListener
        }
        
        lifecycleScope.launch {
            try {
                // è°ƒç”¨AI APIè§£æè‡ªç„¶è¯­è¨€
                val request = ParseEventRequest(userInput)
                val response = RetrofitClient.api.parseEventFromText(request)
                
                // AIè¿”å›è§£æç»“æœ
                if (response.error == null) {
                    val parsedEvent = ParsedEvent(
                        title = response.title,      // "å¼€ä¼š"
                        date = response.date,         // "2025-11-13"
                        time = response.time,         // "15:00"
                        location = response.location  // "ä¼šè®®å®¤"
                    )
                    
                    // è‡ªåŠ¨å¡«å……åˆ°è¡¨å•
                    showAddEventDialog().apply {
                        // å¡«å……è§£æåçš„ä¿¡æ¯
                        fillEventForm(parsedEvent)
                    }
                } else {
                    Toast.makeText(this@MainActivity, "è§£æå¤±è´¥: ${response.error}", Toast.LENGTH_SHORT).show()
                }
            } catch (e: Exception) {
                Toast.makeText(this@MainActivity, "è§£æå¤±è´¥: ${e.message}", Toast.LENGTH_SHORT).show()
            }
            dialog.dismiss()
        }
    }
    
    dialog.setView(dialogView)
    dialog.show()
}
```

#### AIè§£æç¤ºä¾‹
```
è¾“å…¥ï¼š"æ˜å¤©ä¸‹åˆ3ç‚¹å¼€ä¼š"
è¾“å‡ºï¼š
{
    "title": "å¼€ä¼š",
    "date": "2025-11-13",
    "time": "15:00",
    "location": null
}

è¾“å…¥ï¼š"ä¸‹å‘¨ä¸‰ä¸Šåˆ9ç‚¹é¢è¯•ï¼Œåœ°ç‚¹åœ¨ç§‘æŠ€å›­"
è¾“å‡ºï¼š
{
    "title": "é¢è¯•",
    "date": "2025-11-19",
    "time": "09:00",
    "location": "ç§‘æŠ€å›­"
}
```

#### è®¾è®¡ä¼˜åŠ¿
1. **ç”¨æˆ·å‹å¥½**ï¼šæ”¯æŒè‡ªç„¶è¯­è¨€è¾“å…¥
2. **æ™ºèƒ½è§£æ**ï¼šè‡ªåŠ¨è¯†åˆ«æ—¶é—´ã€åœ°ç‚¹ç­‰ä¿¡æ¯
3. **æé«˜æ•ˆç‡**ï¼šå‡å°‘æ‰‹åŠ¨è¾“å…¥æ—¶é—´
4. **å®¹é”™æ€§å¼º**ï¼šæ”¯æŒå¤šç§è¡¨è¾¾æ–¹å¼

**æ–‡ä»¶ä½ç½®**ï¼š`adapp/app/src/main/java/com/ncu/kotlincalendar/MainActivity.kt`

---

## 4.7 å¤šè§†å›¾æ¨¡å¼ - çµæ´»çš„æ—¥å†å±•ç¤º

### æŠ€æœ¯äº®ç‚¹
æ”¯æŒæœˆè§†å›¾ã€å‘¨è§†å›¾ã€æ—¥è§†å›¾ä¸‰ç§æ¨¡å¼ï¼Œæ»¡è¶³ä¸åŒä½¿ç”¨åœºæ™¯ã€‚

### å®ç°åŸç†

#### æ ¸å¿ƒä»£ç 
```kotlin
private fun switchViewMode(mode: Int) {
    when (mode) {
        0 -> {
            // æœˆè§†å›¾ï¼šæ˜¾ç¤ºæ•´æœˆæ—¥å† + ä¸‹æ–¹Tab + å¤©æ°”
            monthViewCard.visibility = View.VISIBLE
            weekViewContainer.visibility = View.GONE
            dayViewCard.visibility = View.GONE
            bottomContentCard.visibility = View.VISIBLE
            weatherCard.visibility = View.VISIBLE
            tvSelectedDate.visibility = View.VISIBLE
            btnViewSwitch.text = "ğŸ“… æœˆ"
            
            // æ»šåŠ¨åˆ°é€‰ä¸­æ—¥æœŸæ‰€åœ¨çš„æœˆä»½
            selectedDate?.let { 
                val yearMonth = YearMonth.from(it)
                currentMonth = yearMonth
                calendarView.scrollToMonth(yearMonth)
            }
            
            // æ¢å¤Tabå†…å®¹
            switchContent(currentTab)
            
            // é‡æ–°åŠ è½½æ‰€æœ‰äº‹ä»¶å¹¶åˆ·æ–°æ˜¾ç¤º
            loadAllEvents()
        }
        1 -> {
            // å‘¨è§†å›¾ï¼šæ¨ªå‘7å¤©é€‰æ‹©å™¨ + æ—¶é—´çº¿ï¼ˆä¸æ˜¾ç¤ºåº•éƒ¨å†…å®¹å’Œå¤©æ°”ï¼‰
            monthViewCard.visibility = View.GONE
            weekViewContainer.visibility = View.VISIBLE
            dayViewCard.visibility = View.GONE
            bottomContentCard.visibility = View.GONE
            weatherCard.visibility = View.GONE
            tvSelectedDate.visibility = View.VISIBLE
            btnViewSwitch.text = "ğŸ“… å‘¨"
            
            // æ»šåŠ¨åˆ°é€‰ä¸­æ—¥æœŸæ‰€åœ¨çš„å‘¨
            selectedDate?.let { weekCalendarView.scrollToWeek(it) }
            
            // é‡æ–°åŠ è½½æ‰€æœ‰äº‹ä»¶å¹¶æ›´æ–°æ—¶é—´çº¿
            loadAllEvents()
        }
        2 -> {
            // æ—¥è§†å›¾ï¼šåªæ˜¾ç¤ºæ—¶é—´çº¿ï¼ˆä¸æ˜¾ç¤ºåº•éƒ¨å†…å®¹å’Œå¤©æ°”ï¼‰
            monthViewCard.visibility = View.GONE
            weekViewContainer.visibility = View.GONE
            dayViewCard.visibility = View.VISIBLE
            bottomContentCard.visibility = View.GONE
            weatherCard.visibility = View.GONE
            tvSelectedDate.visibility = View.VISIBLE
            btnViewSwitch.text = "ğŸ“… æ—¥"
            
            // é‡æ–°åŠ è½½æ‰€æœ‰äº‹ä»¶å¹¶æ›´æ–°æ—¶é—´çº¿
            loadAllEvents()
        }
    }
}
```

#### æ•°æ®å…±äº«
```kotlin
// ä¸‰ç§è§†å›¾å…±äº«åŒä¸€æ•°æ®æº
private val eventsList = mutableListOf<Event>()
private val datesWithEvents = mutableSetOf<LocalDate>()
private val datesWithFestivals = mutableMapOf<LocalDate, String>()

// æœˆè§†å›¾ï¼šæ˜¾ç¤ºæ—¥ç¨‹æ ‡è®°ç‚¹
dotView.visibility = if (datesWithEvents.contains(data.date)) View.VISIBLE else View.GONE

// å‘¨è§†å›¾/æ—¥è§†å›¾ï¼šæ˜¾ç¤ºæ—¶é—´çº¿
val filteredEvents = eventsList.filter { event ->
    val eventDate = Instant.ofEpochMilli(event.dateTime)
        .atZone(ZoneId.systemDefault())
        .toLocalDate()
    eventDate == selectedDate
}
timeSlotAdapter.updateEvents(filteredEvents)
```

#### è®¾è®¡ä¼˜åŠ¿
1. **çµæ´»åˆ‡æ¢**ï¼šä¸€é”®åˆ‡æ¢è§†å›¾æ¨¡å¼
2. **åœºæ™¯é€‚é…**ï¼šä¸åŒåœºæ™¯ä½¿ç”¨ä¸åŒè§†å›¾
3. **æ•°æ®å…±äº«**ï¼šä¸‰ç§è§†å›¾å…±äº«åŒä¸€æ•°æ®æº
4. **æ€§èƒ½ä¼˜åŒ–**ï¼šæŒ‰éœ€åŠ è½½æ•°æ®ï¼Œå‡å°‘å†…å­˜å ç”¨

**æ–‡ä»¶ä½ç½®**ï¼š`adapp/app/src/main/java/com/ncu/kotlincalendar/MainActivity.kt`

---

## 4.8 è®¢é˜…æœºåˆ¶ - çµæ´»çš„æ—¥å†è®¢é˜…

### æŠ€æœ¯äº®ç‚¹
æ”¯æŒè®¢é˜…å…¬å…±æ—¥å†å’ŒèŠ‚æ—¥ï¼Œè‡ªåŠ¨åŒæ­¥åˆ°æœ¬åœ°æ—¥å†ï¼Œæ‰©å±•æ—¥å†åŠŸèƒ½ã€‚

### å®ç°åŸç†

#### è®¢é˜…æµç¨‹
```kotlin
// è®¢é˜…å…¬å…±æ—¥å†
private fun subscribeCalendar(slug: String, name: String) {
    lifecycleScope.launch(Dispatchers.IO) {
        try {
            // 1. è°ƒç”¨APIè·å–æ—¥å†äº‹ä»¶
            val response = RetrofitClient.api.getCalendarFeed(slug)
            
            // 2. åˆ›å»ºè®¢é˜…è®°å½•
            val subscription = Subscription(
                name = name,
                urlSlug = slug,
                isEnabled = true,
                eventCount = response.events_count
            )
            val subscriptionId = subscriptionDao.insert(subscription)
            
            // 3. å°†æ—¥å†äº‹ä»¶è½¬æ¢ä¸ºæœ¬åœ°Eventå¹¶ä¿å­˜
            response.events.forEach { event ->
                val localEvent = EventConverter.toLocalEvent(event)
                localEvent.subscriptionId = subscriptionId
                eventDao.insert(localEvent)
            }
            
            // 4. æ›´æ–°æ—¥å†æ˜¾ç¤º
            withContext(Dispatchers.Main) {
                updateCalendarDots()
                Toast.makeText(this@MainActivity, "âœ… è®¢é˜…æˆåŠŸï¼è·å–äº† ${response.events_count} ä¸ªæ—¥ç¨‹", Toast.LENGTH_LONG).show()
            }
        } catch (e: Exception) {
            withContext(Dispatchers.Main) {
                Toast.makeText(this@MainActivity, "âŒ è®¢é˜…å¤±è´¥ï¼š${e.message}", Toast.LENGTH_LONG).show()
            }
        }
    }
}

// èŠ‚æ—¥è®¢é˜…
class FestivalSubscriptionManager(private val context: Context) {
    private val sharedPreferences = context.getSharedPreferences("festival_subscriptions", Context.MODE_PRIVATE)
    
    fun subscribe(festivalName: String) {
        val current = getSubscribedFestivals().toMutableSet()
        current.add(festivalName)
        saveSubscribedFestivals(current)
    }
    
    fun isSubscribed(festivalName: String): Boolean {
        val subscribed = getSubscribedFestivals()
        return subscribed.any { it == festivalName || it.contains(festivalName, ignoreCase = true) }
    }
}
```

#### è®¢é˜…çŠ¶æ€ç®¡ç†
```kotlin
// è®¢é˜…çš„æ—¥å†äº‹ä»¶è‡ªåŠ¨æ˜¾ç¤º
val festivalEvents = subscriptionManager.getVisibleEvents(null)
    .filter { it.subscriptionId != null }

// æ›´æ–°æ—¥å†æ ‡è®°
val newDatesWithFestivals = festivalEvents.associate { event ->
    val date = Instant.ofEpochMilli(event.dateTime)
        .atZone(ZoneId.systemDefault())
        .toLocalDate()
    date to extractFestivalName(event.title)
}
datesWithFestivals.clear()
datesWithFestivals.putAll(newDatesWithFestivals)
```

#### è®¾è®¡ä¼˜åŠ¿
1. **è‡ªåŠ¨åŒæ­¥**ï¼šè®¢é˜…åè‡ªåŠ¨åŒæ­¥äº‹ä»¶
2. **çµæ´»ç®¡ç†**ï¼šå¯ä»¥è®¢é˜…/å–æ¶ˆè®¢é˜…
3. **æ•°æ®éš”ç¦»**ï¼šè®¢é˜…äº‹ä»¶å’Œç”¨æˆ·äº‹ä»¶åˆ†å¼€ç®¡ç†
4. **æ‰©å±•æ€§å¼º**ï¼šå¯ä»¥è½»æ¾æ·»åŠ æ–°çš„è®¢é˜…æº

**æ–‡ä»¶ä½ç½®**ï¼š
- `adapp/app/src/main/java/com/ncu/kotlincalendar/data/managers/SubscriptionManager.kt`
- `adapp/app/src/main/java/com/ncu/kotlincalendar/data/managers/FestivalSubscriptionManager.kt`

---

## 4.9 åŸå­æ€§UIæ›´æ–° - é˜²æ­¢æ•°æ®ä¸ä¸€è‡´

### æŠ€æœ¯äº®ç‚¹
ä½¿ç”¨ `withContext` ç¡®ä¿UIæ›´æ–°çš„åŸå­æ€§ï¼Œé˜²æ­¢æ•°æ®ä¸ä¸€è‡´å¯¼è‡´çš„UIé—ªçƒã€‚

### å®ç°åŸç†

#### æ ¸å¿ƒä»£ç 
```kotlin
// åŸå­æ€§æ›´æ–°åˆ—è¡¨
private suspend fun loadAllEventsSync() {
    try {
        // 1. åœ¨IOçº¿ç¨‹åŠ è½½æ•°æ®
        val userEvents = if (PreferenceManager.isCloudMode(this@MainActivity) && PreferenceManager.isLoggedIn(this@MainActivity)) {
            val result = eventRepository.getAllEvents()
            result.getOrElse { emptyList() }
        } else {
            eventDao.getUserEvents()
        }
        
        val festivalEvents = subscriptionManager.getVisibleEvents(null)
            .filter { it.subscriptionId != null }
        
        // 2. è½¬æ¢ä¸ºé›†åˆå’ŒMap
        val newDatesWithEvents = userEvents.map { event ->
            Instant.ofEpochMilli(event.dateTime)
                .atZone(ZoneId.systemDefault())
                .toLocalDate()
        }.toSet()
        
        val newDatesWithFestivals = festivalEvents.associate { event ->
            val date = Instant.ofEpochMilli(event.dateTime)
                .atZone(ZoneId.systemDefault())
                .toLocalDate()
            date to extractFestivalName(event.title)
        }
        
        // 3. åŸå­æ€§æ›´æ–°UIï¼ˆåœ¨ä¸»çº¿ç¨‹ä¸€æ¬¡æ€§æ›´æ–°ï¼‰
        withContext(Dispatchers.Main) {
            // æ¸…ç©ºæ—§æ•°æ®
            eventsList.clear()
            datesWithEvents.clear()
            datesWithFestivals.clear()
            
            // æ·»åŠ æ–°æ•°æ®
            eventsList.addAll(userEvents)
            datesWithEvents.addAll(newDatesWithEvents)
            datesWithFestivals.putAll(newDatesWithFestivals)
            
            // åˆ·æ–°UI
            updateEventsList()
            calendarView.notifyCalendarChanged()
            weekCalendarView.notifyCalendarChanged()
        }
    } catch (e: Exception) {
        // é”™è¯¯å¤„ç†
    }
}
```

#### è®¾è®¡ä¼˜åŠ¿
1. **åŸå­æ€§**ï¼šä½¿ç”¨ `withContext` ç¡®ä¿UIæ›´æ–°çš„åŸå­æ€§
2. **é˜²æ­¢é—ªçƒ**ï¼šé¿å…æ•°æ®ä¸ä¸€è‡´å¯¼è‡´çš„UIé—ªçƒ
3. **æ€§èƒ½ä¼˜åŒ–**ï¼šæ‰¹é‡æ›´æ–°ï¼Œå‡å°‘UIåˆ·æ–°æ¬¡æ•°
4. **çº¿ç¨‹å®‰å…¨**ï¼šç¡®ä¿UIæ›´æ–°åœ¨ä¸»çº¿ç¨‹æ‰§è¡Œ

**æ–‡ä»¶ä½ç½®**ï¼š`adapp/app/src/main/java/com/ncu/kotlincalendar/MainActivity.kt`

---

## 4.10 ç”Ÿå‘½å‘¨æœŸæ„ŸçŸ¥ - è‡ªåŠ¨ç®¡ç†èµ„æº

### æŠ€æœ¯äº®ç‚¹
ä½¿ç”¨ `lifecycleScope` è‡ªåŠ¨ç®¡ç†åç¨‹ç”Ÿå‘½å‘¨æœŸï¼Œé˜²æ­¢å†…å­˜æ³„æ¼ã€‚

### å®ç°åŸç†

#### æ ¸å¿ƒä»£ç 
```kotlin
// ä½¿ç”¨lifecycleScopeè‡ªåŠ¨ç®¡ç†åç¨‹ç”Ÿå‘½å‘¨æœŸ
class MainActivity : AppCompatActivity() {
    override fun onCreate(savedInstanceState: Bundle?) {
        super.onCreate(savedInstanceState)
        
        // lifecycleScopeä¼šåœ¨Activityé”€æ¯æ—¶è‡ªåŠ¨å–æ¶ˆæ‰€æœ‰åç¨‹
        lifecycleScope.launch {
            loadData()
        }
    }
    
    override fun onDestroy() {
        super.onDestroy()
        // æ‰‹åŠ¨å–æ¶ˆJobï¼ˆé¢å¤–ä¿éšœï¼‰
        loadEventsJob?.cancel()
    }
}
```

#### èµ„æºæ¸…ç†
```kotlin
override fun onDestroy() {
    super.onDestroy()
    
    // 1. å–æ¶ˆåç¨‹Job
    loadEventsJob?.cancel()
    
    // 2. ç§»é™¤Tabç›‘å¬å™¨
    tabListener?.let {
        tabLayout.removeOnTabSelectedListener(it)
    }
    
    // 3. æ¸…ç©ºæ•°æ®åˆ—è¡¨ï¼ˆå¸®åŠ©GCå›æ”¶ï¼‰
    eventsList.clear()
    datesWithEvents.clear()
    datesWithFestivals.clear()
}
```

#### è®¾è®¡ä¼˜åŠ¿
1. **è‡ªåŠ¨ç®¡ç†**ï¼šlifecycleScopeè‡ªåŠ¨ç®¡ç†åç¨‹ç”Ÿå‘½å‘¨æœŸ
2. **é˜²æ­¢æ³„æ¼**ï¼šActivityé”€æ¯æ—¶è‡ªåŠ¨å–æ¶ˆåç¨‹
3. **èµ„æºé‡Šæ”¾**ï¼šæ˜¾å¼æ¸…ç†èµ„æºï¼Œå¸®åŠ©GCå›æ”¶
4. **å†…å­˜ä¼˜åŒ–**ï¼šé¿å…å†…å­˜æ³„æ¼å¯¼è‡´çš„æ€§èƒ½é—®é¢˜

**æ–‡ä»¶ä½ç½®**ï¼š`adapp/app/src/main/java/com/ncu/kotlincalendar/MainActivity.kt`

---

## æ€»ç»“

ä»¥ä¸ŠæŠ€æœ¯äº®ç‚¹çš„å®ç°ï¼Œä¸ä»…æ»¡è¶³äº†åŸºæœ¬åŠŸèƒ½éœ€æ±‚ï¼Œè¿˜æä¾›äº†ï¼š

1. **è‰¯å¥½çš„æ¶æ„**ï¼šæ¸…æ™°çš„åˆ†å±‚æ¶æ„ï¼ŒèŒè´£æ˜ç¡®
2. **ä¼˜ç§€çš„æ€§èƒ½**ï¼šå¼‚æ­¥å¤„ç†ã€åŸå­æ›´æ–°ã€èµ„æºç®¡ç†
3. **ä¼˜ç§€çš„ä½“éªŒ**ï¼šå³æ—¶åé¦ˆã€æµç•…åŠ¨ç”»ã€æ™ºèƒ½åŠŸèƒ½
4. **è‰¯å¥½çš„æ‰©å±•æ€§**ï¼šæ¨¡å—åŒ–è®¾è®¡ã€æ¥å£æŠ½è±¡ã€é…ç½®çµæ´»

è¿™äº›æŠ€æœ¯äº®ç‚¹çš„åº”ç”¨ï¼Œä½¿å¾—Ralendaræ—¥å†åº”ç”¨ä¸ä»…åŠŸèƒ½å®Œæ•´ï¼Œè€Œä¸”ä»£ç è´¨é‡é«˜ã€æ˜“äºç»´æŠ¤å’Œæ‰©å±•ã€‚

